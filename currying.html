<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    /**
     * currying 例子：
     * 功能：记录每天花的钱，单并不关心每天花了多少，只在月底计算一次
     **/
    var cost = (function(){
        var args = [];

        return function(){
            if ( arguments.length === 0 ){
                var money = 0;
                for ( var i = 0, l = args.length; i < l; i++ ){
                    money += args[ i ];
                }
                return money;
            }else{
                [].push.apply( args, arguments );
            }
        }

    })();

    cost( 100 );    // 未真正求值
    cost( 200 );    // 未真正求值
    cost( 300 );    // 未真正求值

    console.log( cost() );       // 求值并输出：600


    /**
     * 通用的currying function：
     * 作用：遍历本月每天的开销并求出它们的总和
     **/
    var currying = function( fn ){
        var args = [];

        return function(){
            if ( arguments.length === 0 ){
                return fn.apply( this, args );
            }else{
                [].push.apply( args, arguments );
                return arguments.callee;
            }
        }

    };

    var cost = (function(){
        var money = 0;

        return function(){
            for ( var i = 0, l = arguments.length; i < l; i++ ){
                money += arguments[ i ];
            }
            return money;
        }

    })();

    var cost = currying( cost );    // 转化成currying函数

    cost( 100 );    // 未真正求值
    cost( 200 );    // 未真正求值
    cost( 300 );    // 未真正求值
    console.log(cost());     // 求值并输出：600


    Function.prototype.uncurrying = function () {
        var self = this;
        return function() {
            var obj = Array.prototype.shift.call( arguments );
            return self.apply( obj, arguments );
        };
    };

    var push = Array.prototype.push.uncurrying();
    console.log(push);

    (function(){
        push( arguments, 4 );
        console.log( arguments );     // 输出：[1, 2, 3, 4]
    })( 1, 2, 3 );



    for ( var i = 0, fn, ary = [ 'push', 'shift', 'forEach' ]; fn = ary[ i++ ]; ){
        Array[ fn ] = Array.prototype[ fn ].uncurrying();
    };

    var obj = {
        "length": 3,
        "0": 1,
        "1": 2,
        "2": 3
    };

    Array.push( obj, 4 );     // 向对象中添加一个元素
    console.log( obj.length );    // 输出：4

    var first = Array.shift( obj );    // 截取第一个元素
    console.log( first );     // 输出：1
    console.log( obj );    // 输出：{0: 2, 1: 3, 2: 4, length: 3}

    Array.forEach( obj, function( i, n ){
        console.log( n );      // 分别输出：0, 1, 2
    });


    Function.prototype.uncurrying = function () {
        var self = this;     // self此时是Array.prototype.push
        return function() {
            var obj = Array.prototype.shift.call( arguments );
            // obj是{
            //    "length": 1,
            //    "0": 1
            // }
            // arguments对象的第一个元素被截去，剩下[2]
            return self.apply( obj, arguments );
            // 相当于Array.prototype.push.apply( obj, 2 )
        };
    };

    var push = Array.prototype.push.uncurrying();
    var obj = {
        "length": 1,
        "0": 1
    };

    push( obj, 2 );
    console.log( obj );     // 输出：{0: 1, 1: 2, length: 2}


    /**
     * 函数节流
     **/

    var throttle = function ( fn, interval ) {

        var __self = fn,    // 保存需要被延迟执行的函数引用
        timer,      // 定时器
        firstTime = true;    // 是否是第一次调用

        return function () {
            var args = arguments,
                __me = this;

            if ( firstTime ) {    // 如果是第一次调用，不需延迟执行
                __self.apply(__me, args);
                return firstTime = false;
            }

            if ( timer ) {    // 如果定时器还在，说明前一次延迟执行还没有完成
                return false;
            }

            timer = setTimeout(function () {  // 延迟一段时间执行
                clearTimeout(timer);
                timer = null;
                __self.apply(__me, args);

            }, interval || 500 );

        };

    };

    window.onresize = throttle(function(){
        console.log( 1 );
    }, 500 );

    /**
     * 分时函数（为了解决大量操作DOM节点）
     * @param {Array} ary 创建节点时需要用到的数据
     * @param {Function} fn 封装了创建节点逻辑的函数
     * @param {Number} count 表示每一批创建的节点数量
     */
    var timeChunk = function( ary, fn, count ){

        var obj,
        t;

        var len = ary.length;

        var start = function(){
            for ( var i = 0; i < Math.min( count || 1, ary.length ); i++ ){
                var obj = ary.shift();
                fn( obj );
            }
        };

        return function(){
            t = setInterval(function(){
                if ( ary.length === 0 ){  // 如果全部节点都已经被创建好
                    return clearInterval( t );
                }
                start();
            }, 200 );    // 分批执行的时间间隔，也可以用参数的形式传入

        };

    };

    var addEvent = function( elem, type, handler ){
            if ( window.addEventListener ){
              return elem.addEventListener( type, handler, false );
              }
              if ( window.attachEvent ){
                  return elem.attachEvent( 'on' + type, handler );
              }
        };
    /**
     * 把嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就立刻进行一次判断，
     * 以便让addEvent返回一个包裹了正确逻辑的函数
     */
    var addEvent = (function(){
        if ( window.addEventListener ){
            return function( elem, type, handler ){
                elem.addEventListener( type, handler, false );
            }
        }
        if ( window.attachEvent ){
            return function( elem, type, handler ){
                elem.attachEvent( 'on' + type, handler );
            }
        }
    })();


    /**
     * 惰性加载函数
     * 在第一次进入条件分支之后，在函数内部会重写这个函数，重写之后的函数就是我们期望的addEvent函数，
     * 在下一次进入addEvent函数的时候，addEvent函数里不再存在条件分支语句
     */
    var addEvent = function( elem, type, handler ){
        if ( window.addEventListener ){
            addEvent = function( elem, type, handler ){
                elem.addEventListener( type, handler, false );
            }
        }else if ( window.attachEvent ){
            addEvent = function( elem, type, handler ){
                elem.attachEvent( 'on' + type, handler );
            }
        }

        addEvent( elem, type, handler );
    };
    var div = document.getElementById( 'div1' );

    // addEvent( div, 'click', function(){
    //     alert (1);
    // });

    // addEvent( div, 'click', function(){
    //     alert (2);
    // });

</script>
</html>