<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>

<!-- <script>
 /**
  * 在miniConsole.js加载之前，为了能够让用户正常地使用里面的API，
    通常我们的解决方案是用一个占位的miniConsole代理对象来给用户提前使用，
    这个代理对象提供给用户的接口，跟实际的miniConsole是一样的。
  */   
var cache = [];

var miniConsole = {
    log: function(){
        debugger
        var args = arguments;
        cache.push( function(){
            return miniConsole.log.apply( miniConsole, args );
        });
    }
};

miniConsole.log(1);

var handler = function( ev ){
    if ( ev.keyCode === 13 ){
        debugger
        var script = document.createElement( 'script' );
        script.onload = function(){
            for ( var i = 0, fn; fn = cache[ i++ ]; ){
                fn();
            }
        };
        script.src = 'miniConsole.js';
        document.getElementsByTagName( 'head' )[0].appendChild( script );
    }
};

document.body.addEventListener( 'keydown', handler, false );

</script> -->
<script>
var miniConsole = (function(){
    var cache = [];
    var handler = function( ev ){
        if ( ev.keyCode === 13 ){
            var script = document.createElement( 'script' );
            script.onload = function(){
                for ( var i = 0, fn; fn = cache[ i++ ]; ){
                    fn();
                }
            };
            script.src = 'miniConsole.js';
            document.getElementsByTagName( 'head' )[0].appendChild( script );
            document.body.removeEventListener( 'keydown', handler ); // 只加载一次miniConsole.js
        }
    };

    document.body.addEventListener( 'keydown', handler, false );

    return {
        log: function(){
            var args = arguments;
            cache.push( function(){
                return miniConsole.log.apply( miniConsole, args );
            });
        }
    }
})();

miniConsole.log( 11 );      // 开始打印log
/**
 * 
 * 我们在常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后，
 * 下次再请求同一页的时候，便可以直接使用之前的数据。显然这里也可以引入缓存代理，实现方式跟计算乘积的例子差不多，
 * 唯一不同的是，请求数据是个异步的操作，我们无法直接把计算结果放到代理对象的缓存中，而是要通过回调的方式。
*/
</script>
</html>